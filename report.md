# 一、 实验目的
学习生产者与消费者的运行基本原理，学习使用共享内存区和信号量机制，\
学习使用多进程以及进程间通信的方法，学会使用锁互斥访问对象。
# 二、 实验内容
• 一个大小为 3 的缓冲区，初始为空\
• 2 个生产者\
– 随机等待一段时间，往缓冲区添加数据，\
– 若缓冲区已满，等待消费者取走数据后再添加\
– 重复 6 次\
• 3 个消费者\
– 随机等待一段时间，从缓冲区读取数据\
– 若缓冲区为空，等待生产者添加数据后再读取\
– 重复 4 次\
说明：\
• 显示每次添加和读取数据的时间及缓冲区里的数据（指缓冲区里的具体内容）\
• 生产者和消费者用进程模拟（不能用线程）\
• Linux/Window 下都需要做
# 三、 实验环境
Windows10\
VMWare16\
Ubuntu-18.04
# 四、 程序设计与实现
## 通用的简要设计思路：
### (1) 主进程
    负责创建公共信号量和共享内存区，以及创建并等待 2 个生产者子进程和 3 个消费者子进程
### (2) 共享内存区
    需要包括大小为 3 的缓冲区数组 a、缓冲区数据头部指针 beg、缓冲区数据尾部指针 end
### (3) 公共信号量
    共需 3 个，分别是：
    同步信号量 Filled，指示已填充的缓冲区个数，初值为 0
    同步信号量 Emptyed，指示为空的缓冲区个数，初值为 3
    互斥信号量 ReadWriteLock，类似读写锁，控制子进程互斥地使用缓冲区，初值为 1
### (4) 生产者子进程
    需要对共享内存区进行读写操作并在缓冲区内填入数据，
    这还涉及到信号量的申请与释放，其具体每次生产执行过程可以抽象为
    P(Emptyed); //申请空闲缓冲区资源
    P(ReadWriteLock); //申请对缓冲区修改的权限
    array[end]=x //在空缓冲区填入数据
    end=(end+1)%3 //尾部指针递增
    V(Filled); //填充了一个缓冲区，释放填充缓冲区信号量
    V(ReadWriteLock); //释放修改权限
    (5) 消费者子进程需要对共享内存区进行读写操作并在缓冲区内读出数据，
    其每次消费具体执行过程可以抽象为
    P(Filled); //申请已填充缓冲区资源
    P(ReadWriteLock); //申请对缓冲区修改的权限
    y=array[begin] //从已填充缓冲区读取数据
    beg=(beg+1)%3 //头部指针递增
    V(Emptyed); //读取了一个缓冲区，释放空缓冲区信号量
    V(ReadWriteLock); //释放修改权限
### (6) 生产者消费者子进程全部运行结束后，主进程需要回收共享内存区和信号量
## 接下来开始介绍两个操作系统更具体的设计实现思路，为方便查看，先说明宏定义
    生产者总数#define producerAmount 2  
    一个生产者生产出的数据量#define productProducedByOneProducer 6
    消费者总数#define consumerAmount 3
    一个消费者消费的数据量#define productConsumedByOneConsumer 4
    进程总量#define processAmount 5
    缓冲区大小#define bufferSize 3